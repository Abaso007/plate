{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "docs-editor",
  "type": "registry:file",
  "title": "Editor Configuration",
  "description": "Learn how to configure and customize the Plate editor.",
  "files": [
    {
      "path": "../../docs/editor.mdx",
      "content": "---\ntitle: Editor Configuration\ndescription: Learn how to configure and customize the Plate editor.\n---\n\nThis guide covers the configuration options for the Plate editor, including basic setup, plugin management, and advanced configuration techniques.\n\n## Basic Editor Configuration\n\nTo create a basic Plate editor, you can use the `createPlateEditor` function, or `usePlateEditor` in a React component:\n\n```ts\nimport { createPlateEditor } from '@udecode/plate/react';\n\nconst editor = createPlateEditor({\n  plugins: [ParagraphPlugin, HeadingPlugin],\n});\n```\n\n### Initial Value\n\nSet the initial content of the editor:\n\n```ts\nconst editor = createPlateEditor({\n  plugins: [ParagraphPlugin],\n  value: [\n    {\n      type: 'p',\n      children: [{ text: 'Hello, Plate!' }],\n    },\n  ],\n});\n```\n\nYou can also initialize the editor with an HTML string and the associated plugins:\n\n```ts\nconst editor = createPlateEditor({\n  plugins: [BoldPlugin, ItalicPlugin],\n  value: '<p>This is <b>bold</b> and <i>italic</i> text!</p>',\n});\n```\n\nFor a comprehensive list of plugins that support HTML string deserialization, refer to the [Plugin Deserialization Rules](/docs/html#plugin-deserialization-rules) section.\n\n### Async Initial Value\n\nIf you need to fetch the initial value asynchronously (e.g., from an API), you can use the `skipInitialization` option and call `editor.tf.init` once your data is ready:\n\n```tsx\nfunction AsyncEditor() {\n  const [initialValue, setInitialValue] = React.useState();\n  const [loading, setLoading] = React.useState(true);\n  const editor = usePlateEditor({\n    skipInitialization: true,\n    plugins: [ParagraphPlugin],\n  });\n\n  React.useEffect(() => {\n    // Simulate async fetch\n    setTimeout(() => {\n      setInitialValue([\n        {\n          type: 'p',\n          children: [{ text: 'Loaded async value!' }],\n        },\n      ]);\n      setLoading(false);\n    }, 1000);\n  }, []);\n\n  React.useEffect(() => {\n    if (!loading && initialValue) {\n      editor.tf.init({ value: initialValue });\n    }\n  }, [loading, initialValue, editor]);\n\n  if (loading) return <div>Loadingâ€¦</div>;\n\n  return (\n    <Plate editor={editor}>\n      <EditorContainer>\n        <Editor />\n      </EditorContainer>\n    </Plate>\n  );\n}\n```\n\nThis pattern is useful when you need to wait for data before initializing the editor, such as when loading content from a server or database.\n\n### Adding Plugins\n\nYou can add plugins to your editor by including them in the `plugins` array:\n\n```ts\nconst editor = createPlateEditor({\n  plugins: [ParagraphPlugin, HeadingPlugin, ListPlugin],\n});\n```\n\n### Max Length\n\nSet the maximum length of the editor:\n\n```ts\nconst editor = createPlateEditor({\n  plugins: [ParagraphPlugin],\n  maxLength: 100,\n});\n```\n\n## Advanced Configuration\n\n### Id\n\nSet a custom id for the editor:\n\n```ts\nconst editor = createPlateEditor({\n  plugins: [ParagraphPlugin],\n  id: 'my-custom-editor-id',\n});\n```\n\nIf defined, you should always pass the `id` as the first argument in any editor retrieval methods.\n\n### Normalization\n\nControl whether the editor should normalize its content on initialization:\n\n```ts\nconst editor = createPlateEditor({\n  plugins: [ParagraphPlugin],\n  shouldNormalizeEditor: true,\n});\n```\n\nNote that normalization may take a few dozen milliseconds for large documents, such as the playground value.\n\n### Auto-selection\n\nConfigure the editor to automatically select a range:\n\n```ts\nconst editor = createPlateEditor({\n  plugins: [ParagraphPlugin],\n  autoSelect: 'end', // or 'start', or true\n});\n```\n\nThis is not the same as auto-focus: you can select text without focusing the editor.\n\n### Component Overrides\n\nOverride default components for plugins:\n\n```ts\nconst editor = createPlateEditor({\n  plugins: [ParagraphPlugin, HeadingPlugin],\n  components: {\n    [ParagraphPlugin.key]: CustomParagraphComponent,\n    [HeadingPlugin.key]: CustomHeadingComponent,\n  },\n});\n```\n\n### Plugin Overrides\n\nOverride specific plugin configurations:\n\n```ts\nconst editor = createPlateEditor({\n  plugins: [ParagraphPlugin, HeadingPlugin],\n  override: {\n    plugins: {\n      [ParagraphPlugin.key]: {\n        options: {\n          customOption: true,\n        },\n      },\n    },\n  },\n});\n```\n\n### Disable Plugins\n\nDisable specific plugins:\n\n```ts\nconst editor = createPlateEditor({\n  plugins: [ParagraphPlugin, HeadingPlugin, ListPlugin],\n  override: {\n    enabled: {\n      [HistoryPlugin.key]: false,\n    },\n  },\n});\n```\n\n### Overriding Plugins\n\nYou can override core plugins or previously defined plugins by adding a plugin with the same key. The last plugin with a given key wins:\n\n```ts\nconst CustomParagraphPlugin = createPlatePlugin({\n  key: 'p',\n  // Custom implementation\n});\n\nconst editor = createPlateEditor({\n  plugins: [ParagraphPlugin, CustomParagraphPlugin],\n});\n```\n\n### Root Plugin\n\nFrom the root plugin, you can configure any plugin:\n\n```ts\nconst editor = createPlateEditor({\n  plugins: [ParagraphPlugin, HeadingPlugin],\n  rootPlugin: (plugin) =>\n    plugin.configurePlugin(LengthPlugin, {\n    options: {\n        maxLength: 100,\n      },\n    }),\n});\n```\n\n## Typed Editor\n\n`createPlateEditor` will automatically infer the types for your editor from the value and the plugins you pass in. For explicit type creation, use the generics:\n\n### Plugins Type\n\n```ts\nconst editor = createPlateEditor<Value, typeof TablePlugin | typeof LinkPlugin>({\n  plugins: [TablePlugin, LinkPlugin],\n});\n\n// Usage\neditor.tf.insert.tableRow()\n```\n\n### Value Type\n\nFor more complex editors, you can define your types in a separate file (e.g., `plate-types.ts`):\n\n```ts\nimport type { TElement, TText } from '@udecode/plate';\nimport type { TPlateEditor } from '@udecode/plate/react';\n\n// Define custom element types\ninterface ParagraphElement extends TElement {\n  align?: 'left' | 'center' | 'right' | 'justify';\n  children: RichText[];\n  type: typeof ParagraphPlugin.key;\n}\n\ninterface ImageElement extends TElement {\n  children: [{ text: '' }]\n  type: typeof ImagePlugin.key;\n  url: string;\n}\n\n// Define custom text types\ninterface FormattedText extends TText {\n  bold?: boolean;\n  italic?: boolean;\n}\n\nexport type MyRootBlock = ParagraphElement | ImageElement;\n\n// Define the editor's value type\nexport type MyValue = MyRootBlock[];\n\n// Define the custom editor type\nexport type MyEditor = TPlateEditor<MyValue, typeof TablePlugin | typeof LinkPlugin>;\n\nexport const useMyEditorRef = () => useEditorRef<MyEditor>();\n\n// Usage\nconst value: MyValue = [{\n  type: 'p',\n  children: [{ text: 'Hello, Plate!' }],\n}]\n\nconst editorInferred = createPlateEditor({\n  plugins: [TablePlugin, LinkPlugin],\n  value,\n});\n\n// or \nconst editorExplicit = createPlateEditor<MyValue, typeof TablePlugin | typeof LinkPlugin>({\n  plugins: [TablePlugin, LinkPlugin],\n  value,\n});\n```\n\n### Benefits\n\nWe strongly recommend using typed editors for the following reasons:\n\n1. **Type Safety**: The editor enforces the structure of your document, preventing invalid operations.\n2. **Autocomplete**: Your IDE can provide better autocomplete suggestions based on your custom types.\n3. **Refactoring**: Changing types in one place will highlight necessary changes throughout your codebase.\n4. **Documentation**: Types serve as a form of self-documentation for your editor's structure and capabilities.\n",
      "type": "registry:file",
      "target": "content/docs/plate/guides/editor/index.mdx"
    }
  ]
}