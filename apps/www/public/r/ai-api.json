{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "ai-api",
  "type": "registry:file",
  "dependencies": [
    "@ai-sdk/openai@1.3.23",
    "ai@4.3.19",
    "@ai-sdk/provider@1.1.3",
    "@ai-sdk/provider-utils@2.2.8"
  ],
  "registryDependencies": [
    "https://platejs.org/r/copilot-api",
    "https://platejs.org/r/markdown-joiner-transform"
  ],
  "files": [
    {
      "path": "src/registry/app/api/ai/command/route.ts",
      "content": "import type {\n  ChatMessage,\n  ToolName,\n} from '@/registry/components/editor/use-chat';\nimport type { NextRequest } from 'next/server';\n\nimport { google } from '@ai-sdk/google';\nimport { replacePlaceholders } from '@platejs/ai';\nimport { serializeMd } from '@platejs/markdown';\nimport {\n  convertToModelMessages,\n  createUIMessageStream,\n  createUIMessageStreamResponse,\n  generateObject,\n  streamObject,\n  streamText,\n} from 'ai';\nimport { NextResponse } from 'next/server';\nimport { type SlateEditor, createSlateEditor, nanoid, RangeApi } from 'platejs';\nimport { z } from 'zod';\n\nimport { BaseEditorKit } from '@/registry/components/editor/editor-base-kit';\nimport { markdownJoinerTransform } from '@/registry/lib/markdown-joiner-transform';\n\nexport async function POST(req: NextRequest) {\n  const { apiKey: key, ctx, messages: messagesRaw } = await req.json();\n\n  const { children, selection, toolName: toolNameParam } = ctx;\n\n  const editor = createSlateEditor({\n    plugins: BaseEditorKit,\n    selection,\n    value: children,\n  });\n\n  const apiKey = key || process.env.OPENAI_API_KEY;\n\n  if (!apiKey) {\n    return NextResponse.json(\n      { error: 'Missing OpenAI API key.' },\n      { status: 401 }\n    );\n  }\n\n  const isSelecting = editor.api.isExpanded();\n\n  try {\n    const stream = createUIMessageStream<ChatMessage>({\n      execute: async ({ writer }) => {\n        const lastIndex = messagesRaw.findIndex(\n          (message: any) => message.role === 'user'\n        );\n\n        const messages = [...messagesRaw];\n\n        messages[lastIndex] = replaceMessagePlaceholders(\n          editor,\n          messages[lastIndex],\n          {\n            isSelecting,\n          }\n        );\n\n        const lastUserMessage = messages[lastIndex];\n\n        let toolName = toolNameParam;\n\n        if (!toolName) {\n          const { object: AIToolName } = await generateObject({\n            enum: isSelecting\n              ? ['generate', 'edit', 'comment']\n              : ['generate', 'comment'],\n            model: google('gemini-2.5-flash'),\n            output: 'enum',\n            prompt: `User message:\n            ${JSON.stringify(lastUserMessage)}`,\n            system: chooseToolSystem,\n          });\n\n          writer.write({\n            data: AIToolName as ToolName,\n            type: 'data-toolName',\n          });\n\n          toolName = AIToolName;\n        }\n\n        if (toolName === 'generate') {\n          const generateSystem = replacePlaceholders(\n            editor,\n            generateSystemTemplate({ isSelecting })\n          );\n\n          const gen = streamText({\n            experimental_transform: markdownJoinerTransform(),\n            maxOutputTokens: 2048,\n            messages: convertToModelMessages(messages),\n            model: google('gemini-2.5-flash'),\n            system: generateSystem,\n          });\n\n          writer.merge(gen.toUIMessageStream({ sendFinish: false }));\n        }\n\n        if (toolName === 'edit') {\n          if (!isSelecting)\n            throw new Error('Edit tool is only available when selecting');\n\n          const editSystem = replacePlaceholders(editor, editSystemTemplate());\n\n          const edit = streamText({\n            experimental_transform: markdownJoinerTransform(),\n            maxOutputTokens: 2048,\n            messages: convertToModelMessages(messages),\n            model: google('gemini-2.5-flash'),\n            system: editSystem,\n          });\n\n          writer.merge(edit.toUIMessageStream({ sendFinish: false }));\n        }\n\n        if (toolName === 'comment') {\n          const lastUserMessage = messagesRaw[lastIndex] as ChatMessage;\n          const prompt = lastUserMessage.parts.find(\n            (p) => p.type === 'text'\n          )?.text;\n\n          const commentPrompt = replacePlaceholders(\n            editor,\n            commentPromptTemplate({ isSelecting }),\n            {\n              prompt,\n            }\n          );\n\n          const { elementStream } = streamObject({\n            maxOutputTokens: 2048,\n            model: google('gemini-2.5-flash'),\n            output: 'array',\n            prompt: removeEscapeSelection(editor, commentPrompt),\n            schema: z\n              .object({\n                blockId: z\n                  .string()\n                  .describe(\n                    'The id of the starting block. If the comment spans multiple blocks, use the id of the first block.'\n                  ),\n                comment: z\n                  .string()\n                  .describe(\n                    'A brief comment or explanation for this fragment.'\n                  ),\n                content: z\n                  .string()\n                  .describe(\n                    String.raw`The original document fragment to be commented on.It can be the entire block, a small part within a block, or span multiple blocks. If spanning multiple blocks, separate them with two \\n\\n.`\n                  ),\n              })\n              .describe('A single comment'),\n            system: commentSystem,\n          });\n\n          // Create a single message ID for the entire comment stream\n\n          for await (const comment of elementStream) {\n            const commentDataId = nanoid();\n            // Send each comment as a delta\n\n            writer.write({\n              id: commentDataId,\n              data: comment,\n              type: 'data-comment',\n            });\n          }\n        }\n      },\n    });\n\n    return createUIMessageStreamResponse({ stream });\n  } catch {\n    return NextResponse.json(\n      { error: 'Failed to process AI request' },\n      { status: 500 }\n    );\n  }\n}\n\nconst generateSystemTemplate = ({ isSelecting }: { isSelecting: boolean }) => {\n  return isSelecting\n    ? PROMPT_TEMPLATES.generateSystemDefault\n    : PROMPT_TEMPLATES.generateSystemSelecting;\n};\n\nconst editSystemTemplate = () => {\n  return PROMPT_TEMPLATES.editSystemSelecting;\n};\n\nconst promptTemplate = ({ isSelecting }: { isSelecting: boolean }) => {\n  return isSelecting\n    ? PROMPT_TEMPLATES.promptSelecting\n    : PROMPT_TEMPLATES.promptDefault;\n};\n\nconst commentPromptTemplate = ({ isSelecting }: { isSelecting: boolean }) => {\n  return isSelecting\n    ? PROMPT_TEMPLATES.commentPromptSelecting\n    : PROMPT_TEMPLATES.commentPromptDefault;\n};\n\nconst chooseToolSystem = `You are a strict classifier. Classify the user's last request as \"generate\", \"edit\", or \"comment\".\n\nPriority rules:\n1. Default is \"generate\". Any open question, idea request, or creation request → \"generate\".\n2. Only return \"edit\" if the user provides original text (or a selection of text) AND asks to change, rephrase, translate, or shorten it.\n3. Only return \"comment\" if the user explicitly asks for comments, feedback, annotations, or review. Do not infer \"comment\" implicitly.\n\nReturn only one enum value with no explanation.`;\n\nconst commentSystem = `You are a document review assistant.  \nYou will receive an MDX document wrapped in <block id=\"...\"> content </block> tags.  \n<Selection> is the text highlighted by the user.\n\nYour task:  \n- Read the content of all blocks and provide comments.  \n- For each comment, generate a JSON object:  \n  - blockId: the id of the block being commented on.\n  - content: the original document fragment that needs commenting.\n  - comments: a brief comment or explanation for that fragment.\n\nRules:\n- IMPORTANT: If a comment spans multiple blocks, use the id of the **first** block.\n- The **content** field must be the original content inside the block tag. The returned content must not include the block tags, but should retain other MDX tags.\n- IMPORTANT: The **content** field must be flexible:\n  - It can cover one full block, only part of a block, or multiple blocks.  \n  - If multiple blocks are included, separate them with two \\\\n\\\\n.  \n  - Do NOT default to using the entire block—use the smallest relevant span instead.\n- At least one comment must be provided.\n- If a <Selection> exists, Your comments should come from the <Selection>, and if the <Selection> is too long, there should be more than one comment.\n`;\n\nconst systemCommon = `\\\nYou are an advanced AI-powered note-taking assistant, designed to enhance productivity and creativity in note management.\nRespond directly to user prompts with clear, concise, and relevant content. Maintain a neutral, helpful tone.\n\nRules:\n- <Document> is the entire note the user is working on.\n- <Reminder> is a reminder of how you should reply to INSTRUCTIONS. It does not apply to questions.\n- Anything else is the user prompt.\n- Your response should be tailored to the user's prompt, providing precise assistance to optimize note management.\n- For INSTRUCTIONS: Follow the <Reminder> exactly. Provide ONLY the content to be inserted or replaced. No explanations or comments.\n- For QUESTIONS: Provide a helpful and concise answer. You may include brief explanations if necessary.\n- CRITICAL: DO NOT remove or modify the following custom MDX tags: <u>, <callout>, <kbd>, <toc>, <sub>, <sup>, <mark>, <del>, <date>, <span>, <column>, <column_group>, <file>, <audio>, <video> in <Selection> unless the user explicitly requests this change.\n- CRITICAL: Distinguish between INSTRUCTIONS and QUESTIONS. Instructions typically ask you to modify or add content. Questions ask for information or clarification.\n- CRITICAL: when asked to write in markdown, do not start with \\`\\`\\`markdown.\n- CRITICAL: When writing the column, such line breaks and indentation must be preserved.\n<column_group>\n  <column>\n    1\n  </column>\n  <column>\n    2\n  </column>\n  <column>\n    3\n  </column>\n</column_group>\n`;\n\nconst generateSystemDefault = `\\\n${systemCommon}\n- <Block> is the current block of text the user is working on.\n\n<Block>\n{block}\n</Block>\n`;\n\nconst generateSystemSelecting = `\\\n${systemCommon}\n- <Block> contains the text context. You will always receive one <Block>.\n- <selection> is the text highlighted by the user.\n`;\n\nconst editSystemSelecting = `\\\n- <Block> shows the full sentence or paragraph, only for context. \n- <Selection> is the exact span of text inside <Block> that must be replaced. \n- Your output MUST be only the replacement string for <Selection>, with no tags. \n- Never output <Block> or <Selection> tags, and never output surrounding text. \n- The replacement must be grammatically correct when substituted back into <Block>. \n- Ensure the replacement fits seamlessly so the whole <Block> reads naturally. \n- Output must be limited to the replacement string itself.\n- Do not remove the \\\\n in the original text\n`;\n\nconst promptDefault = `<Reminder>\nCRITICAL: NEVER write <Block>.\n</Reminder>\n{prompt}`;\n\nconst promptSelecting = `<Reminder>\nIf this is a question, provide a helpful and concise answer about <Selection>.\nIf this is an instruction, provide ONLY the text to replace <Selection>. No explanations.\nEnsure it fits seamlessly within <Block>. If <Block> is empty, write ONE random sentence.\nNEVER write <Block> or <Selection>.\n</Reminder>\n{prompt} about <Selection>\n\n<Block>\n{block}\n</Block>\n`;\n\nconst commentPromptSelecting = `\nComment on the content within the <Selection>.\nNever write <Selection>.\n{prompt}:\n        \n{blockWithBlockId}\n`;\n\nconst commentPromptDefault = `{prompt}:\n        \n{editorWithBlockId}\n`;\n\nconst PROMPT_TEMPLATES = {\n  commentPromptDefault,\n  commentPromptSelecting,\n  editSystemSelecting,\n  generateSystemDefault,\n  generateSystemSelecting,\n  promptDefault,\n  promptSelecting,\n};\n\nconst replaceMessagePlaceholders = (\n  editor: SlateEditor,\n  message: ChatMessage,\n  { isSelecting }: { isSelecting: boolean }\n): ChatMessage => {\n  if (isSelecting) addSelection(editor);\n\n  const template = promptTemplate({ isSelecting });\n\n  const parts = message.parts.map((part) => {\n    if (part.type !== 'text' || !part.text) return part;\n\n    let text = replacePlaceholders(editor, template, {\n      prompt: part.text,\n    });\n\n    if (isSelecting) text = removeEscapeSelection(editor, text);\n\n    return { ...part, text } as typeof part;\n  });\n\n  return { ...message, parts };\n};\n\nconst SELECTION_START = '<Selection>';\nconst SELECTION_END = '</Selection>';\n\nconst addSelection = (editor: SlateEditor) => {\n  if (!editor.selection) return;\n\n  if (editor.api.isExpanded()) {\n    const [start, end] = RangeApi.edges(editor.selection);\n\n    editor.tf.withoutNormalizing(() => {\n      editor.tf.insertText(SELECTION_END, {\n        at: end,\n      });\n\n      editor.tf.insertText(SELECTION_START, {\n        at: start,\n      });\n    });\n  }\n};\n\nconst removeEscapeSelection = (editor: SlateEditor, text: string) => {\n  let newText = text\n    .replace(`\\\\${SELECTION_START}`, SELECTION_START)\n    .replace(`\\\\${SELECTION_END}`, SELECTION_END);\n\n  // If the selection is on a void element, inserting the placeholder will fail, and the string must be replaced manually.\n  if (!newText.includes(SELECTION_END)) {\n    const [_, end] = RangeApi.edges(editor.selection!);\n\n    const node = editor.api.block({ at: end.path });\n\n    if (!node) return newText;\n\n    if (editor.api.isVoid(node[0])) {\n      const voidString = serializeMd(editor, { value: [node[0]] });\n\n      const idx = newText.lastIndexOf(voidString);\n\n      if (idx !== -1) {\n        newText =\n          newText.slice(0, idx) +\n          voidString.trimEnd() +\n          SELECTION_END +\n          newText.slice(idx + voidString.length);\n      }\n    }\n  }\n\n  return newText;\n};\n",
      "type": "registry:file",
      "target": "app/api/ai/command/route.ts"
    }
  ]
}