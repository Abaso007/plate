{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "installation-rsc-docs",
  "type": "registry:file",
  "title": "RSC",
  "description": "Install and configure Plate for React Server Components",
  "files": [
    {
      "path": "../../docs/installation/rsc.mdx",
      "content": "---\ntitle: RSC\ndescription: Install and configure Plate for React Server Components\n---\n\nThis guide demonstrates how to use Plate in React Server Components (RSC) for tasks like static content generation or server-side data processing. Plate's core is designed to be server-safe, allowing you to work with editor content without a browser environment.\n\n<Callout type=\"warning\" title=\"Key RSC Constraint\">\n  When using Plate in RSC, you **must not** import from `/react` subpaths of any `@udecode/plate*` package. Always use the base imports (e.g., `@udecode/plate-basic-nodes` instead of `@udecode/plate-basic-nodes/react`).\n\n  This means you cannot use `createPlateEditor` from `@udecode/plate/react`. Instead, use `createSlateEditor` from `@udecode/plate`.\n</Callout>\n\n<Steps>\n\n### Install Plate\n\nInstall the core Plate package and any specific plugin packages you need.\n\n```bash\nnpm add @udecode/plate @udecode/plate-basic-nodes\n```\n\n### Create an Editor Instance\n\nIn an RSC environment, you use `createSlateEditor` from `@udecode/plate` to initialize an editor instance. This function doesn't rely on React hooks or client-side specific code.\n\nHere's an example demonstrating how to set up an editor with various plugins, similar to the [Server-Side Example](/docs/examples/server-side):\n\n```tsx title=\"app/api/generate-doc/route.ts\"\nimport { createSlateEditor } from '@udecode/plate';\nimport { AutoformatPlugin } from '@udecode/plate-autoformat';\nimport { BaseTextAlignPlugin } from '@udecode/plate-basic-styles';\nimport {\n  BaseBoldPlugin,\n  BaseCodePlugin,\n  BaseItalicPlugin,\n  BaseBlockquotePlugin,\n  BaseH1Plugin,\n  BaseH2Plugin,\n  BaseH3Plugin,\n} from '@udecode/plate-basic-nodes';\nimport { MarkdownPlugin, remarkMdx } from '@udecode/plate-markdown';\nimport remarkGfm from 'remark-gfm';\nimport remarkMath from 'remark-math';\n\n// Example initial value\nconst initialValue = [\n  { type: 'h1', children: [{ text: 'Server-Generated Document' }] },\n  { type: 'p', children: [{ text: 'This content was processed on the server.' }] },\n  { type: 'blockquote', children: [{ text: 'This is a quote.' }] },\n  { type: 'p', children: [{ text: 'And this is bold.', bold: true }] },\n];\n\n// Create the editor instance\nconst editor = createSlateEditor({\n  plugins: [\n    // Block plugins\n    BaseH1Plugin,\n    BaseH2Plugin,\n    BaseH3Plugin,\n    BaseBlockquotePlugin,\n    BaseTextAlignPlugin,\n    // ... add more element plugins as needed\n\n    // Mark plugins\n    BaseBoldPlugin,\n    BaseItalicPlugin,\n    BaseCodePlugin,\n    // ... add more mark plugins\n\n    // Functionality plugins\n    AutoformatPlugin,\n    MarkdownPlugin.configure({ // For serialization example\n      options: {\n        remarkPlugins: [remarkMath, remarkGfm, remarkMdx],\n      },\n    }),\n    // ... add other functional plugins\n  ],\n  value: initialValue, // Set initial content\n});\n\n// You can now use editor.children, editor.api, editor.tf, etc.\n// For example, to get the text content:\nconst textContent = editor.api.string([]);\n// console.debug('Text Content:', textContent);\n\n// Or to serialize to Markdown:\nconst markdown = editor.api.markdown.serialize();\n// console.debug('Markdown Output:', markdown);\n\n// The editor instance can be used for various server-side tasks.\n// For a complete example of using this in an RSC page for rendering,\n// see the /docs/examples/server-side page.\n```\n\n<Callout type=\"info\">\n  `createSlateEditor` creates a raw Slate editor instance. It's suitable for server-side logic, data transformation, or preparing content for static rendering. Check out the full [Server-Side Example](/docs/examples/server-side) to see it in action.\n</Callout>\n\n### Content Manipulation\n\nThe primary use case for Plate in RSC is programmatic content manipulation:\n\n-   **[`editor.api`](/docs/api/slate/editor-api)**: Access various utility functions for querying the editor state. For example:\n    -   `editor.api.nodes({ at: [], match })`: Find specific nodes.\n    -   `editor.api.string([])`: Extract text content.\n    -   [HTML Serialization](/docs/html)\n    -   [Markdown Serialization](/docs/markdown)\n\n-   **[`editor.tf`](/docs/api/slate/editor-transforms)**: Use transform functions to modify the editor content. For example:\n    -   `editor.tf.insertNodes(nodes, opts)`: Insert new nodes.\n    -   `editor.tf.removeNodes(opts)`: Delete nodes.\n    -   `editor.tf.setNodes(props, opts)`: Update properties of existing nodes.\n    -   `editor.tf.normalize({ force: true })`: Normalize the editor.\n\n</Steps>\n\n### Next Steps\n\nWith Plate configured in your RSC environment, you can now:\n\n*   Build server-side content generation and transformation pipelines.\n*   Perform bulk updates or transformations on your existing Plate documents.\n*   Validate content structure or extract specific data from your documents.\n*   Integrate with other backend services for content processing.\n*   Explore [Markdown Serialization](/docs/markdown), [HTML Serialization](/docs/html), and [`PlateStatic`](/docs/plate-static) if you need to generate static content.",
      "type": "registry:file",
      "target": "content/docs/plate/installation/rsc.mdx"
    }
  ]
}