---
title: Plugin Rules
description: Configure common editing behaviors.
---

Plugin Rules control how editor nodes respond to common user actions. Instead of overriding the editor methods, you can configure these behaviors directly on a plugin's `node` property.

This guide shows you how to use `breakRules`, `deleteRules`, `mergeRules`, `normalizeRules`, and the `matchRules` override to create intuitive editing experiences.

<ComponentPreview name="plugin-rules-demo" />

## Actions

Plugin rules use specific action names to define behavior:

- **`'default'`**: Default Slate behavior.
- **`'reset'`**: Changes the current block to a default paragraph, keeping content.
- **`'exit'`**: Exits the current block, inserting a new paragraph after it. See [Exit Break](/docs/exit-break) to learn more about this behavior.
- **`'deleteExit'`**: Deletes content then exits the block.
- **`'lineBreak'`**: Inserts a line break (`\n`) instead of splitting the block.

### `default`

Standard Slate behavior. For `breakRules`, splits the block. For `deleteRules`, merges with the previous block.

```tsx
<p>
  Hello world|
</p>
```

After pressing `Enter`:

```tsx
<p>Hello world</p>
<p>
  |
</p>
```

After pressing `Backspace`:

```tsx
<p>Hello world|</p>
```

### `reset`

Converts the current block to a default paragraph while preserving content. Custom properties are removed.

```tsx
<h3 listStyleType="disc">
  |
</h3>
```

After pressing `Enter` with `breakRules: { empty: 'reset' }`:

```tsx
<p>
  |
</p>
```

### `exit`

Exits the current block structure by inserting a new paragraph after it.

```tsx
<blockquote>
  |
</blockquote>
```

After pressing `Enter` with `breakRules: { empty: 'exit' }`:

```tsx
<blockquote>
  <text />
</blockquote>
<p>
  |
</p>
```

### `deleteExit`

Deletes content then exits the block.

```tsx
<blockquote>
  line1
  |
</blockquote>
```

After pressing `Enter` with `breakRules: { emptyLineEnd: 'deleteExit' }`:

```tsx
<blockquote>line1</blockquote>
<p>
  |
</p>
```

### `lineBreak`

Inserts a soft line break (`\n`) instead of splitting the block.

```tsx
<blockquote>
  Hello|
</blockquote>
```

After pressing `Enter` with `breakRules: { default: 'lineBreak' }`:

```tsx
<blockquote>
  Hello
  |
</blockquote>
```

## `breakRules`

Controls what happens when users press `Enter` within specific block types.

### Configuration

```tsx
BlockquotePlugin.configure({
  node: {
    breakRules: {
      // Action when Enter is pressed normally
      default: 'default' | 'lineBreak' | 'exit' | 'deleteExit',
      
      // Action when Enter is pressed in an empty block
      empty: 'default' | 'reset' | 'exit' | 'deleteExit',
      
      // Action when Enter is pressed at end of empty line
      emptyLineEnd: 'default' | 'exit' | 'deleteExit',
    },
  },
});
```

Each property controls a specific scenario:

- `default`
  - [`'default'`](#default)
  - [`'lineBreak'`](#linebreak)
  - [`'exit'`](#exit)
  - [`'deleteExit'`](#deleteexit)

- `empty`
  - [`'default'`](#default)
  - [`'reset'`](#reset)
  - [`'exit'`](#exit)
  - [`'deleteExit'`](#deleteexit)

- `emptyLineEnd`
  - [`'default'`](#default)
  - [`'exit'`](#exit)
  - [`'deleteExit'`](#deleteexit)

### Examples

**Blockquote with line breaks and smart exits:**

```tsx
import { BlockquotePlugin } from '@udecode/plate-basic-nodes/react';

const plugins = [
  // ...otherPlugins,
  BlockquotePlugin.configure({
    node: {
      breakRules: {
        default: 'lineBreak',
        empty: 'reset',
        emptyLineEnd: 'deleteExit',
      },
    },
  }),
];
```

Before pressing `Enter` in blockquote:
```tsx
<blockquote>
  Quote text|
</blockquote>
```

After (line break):
```tsx
<blockquote>
  Quote text
  |
</blockquote>
```

**Code block with custom empty handling:**

```tsx
import { CodeBlockPlugin } from '@udecode/plate-code-block/react';

const plugins = [
  // ...otherPlugins,
  CodeBlockPlugin.configure({
    node: {
      deleteRules: { empty: 'reset' },
      matchRules: ({ editor, rule }) => {
        return rule === 'delete.empty' && isCodeBlockEmpty();
      },
    },
  }),
];
```

Before pressing `Backspace` in empty code block:
```tsx
<code_block>
  <code_line>
    |
  </code_line>
</code_block>
```

After (reset):
```tsx
<p>
  |
</p>
```

## `deleteRules`

Controls what happens when users press `Backspace` at specific positions.

### Configuration

```tsx
HeadingPlugin.configure({
  node: {
    deleteRules: {
      // Action when Backspace is pressed at block start
      start: 'default' | 'reset',
      
      // Action when Backspace is pressed in empty block
      empty: 'default' | 'reset',
    },
  },
});
```

Each property controls a specific scenario:

- `start`
  - [`'default'`](#default)
  - [`'reset'`](#reset)

- `empty`
  - [`'default'`](#default)
  - [`'reset'`](#reset)

### Examples

**Reset blockquotes at start:**

```tsx
import { BlockquotePlugin } from '@udecode/plate-basic-nodes/react';

const plugins = [
  // ...otherPlugins,
  BlockquotePlugin.configure({
    node: {
      deleteRules: { start: 'reset' },
    },
  }),
];
```

Before pressing `Backspace` at start:
```tsx
<blockquote>
  |Quote content
</blockquote>
```

After (reset):
```tsx
<p>
  |Quote content
</p>
```

**List items with start reset:**

```tsx
import { ListPlugin } from '@udecode/plate-list/react';

const plugins = [
  // ...otherPlugins,
  ListPlugin.configure({
    node: {
      deleteRules: { start: 'reset' },
      matchRules: ({ rule, node }) => {
        return rule === 'delete.start' && Boolean(node.listStyleType);
      },
    },
  }),
];
```

Before pressing `Backspace` at start of list item:
```tsx
<p listStyleType="disc">
  |List item content
</p>
```

After (reset):
```tsx
<p>
  |List item content
</p>
```

## `mergeRules`

Controls how blocks behave when merging with previous blocks.

### Configuration

```tsx
ParagraphPlugin.configure({
  node: {
    mergeRules: {
      // Whether to remove empty previous blocks when merging
      removeEmpty: boolean,
    },
  },
});
```

### Examples

Only paragraph and heading plugins enable removal by default. Most other plugins use `false`:

```tsx
import { H1Plugin, ParagraphPlugin } from '@udecode/plate/react';

const plugins = [
  // ...otherPlugins,
  H1Plugin, // mergeRules: { removeEmpty: true } by default
  ParagraphPlugin, // mergeRules: { removeEmpty: true } by default
];
```

Before pressing `Backspace` at start:
```tsx
<p>
  <text />
</p>
<h1>
  |Heading content
</h1>
```

After (empty paragraph removed):
```tsx
<h1>
  |Heading content
</h1>
```

**Blockquote with removal disabled:**

```tsx
import { BlockquotePlugin } from '@udecode/plate-basic-nodes/react';

const plugins = [
  // ...otherPlugins,
  BlockquotePlugin.configure({
    node: {
      mergeRules: { removeEmpty: false }, // Default
    },
  }),
];
```

Before pressing `Backspace` at start:
```tsx
<p>
  <text />
</p>
<blockquote>
  |Code content
</blockquote>
```

After (empty paragraph preserved):
```tsx
<p>
  |Code content
</p>
```

<Callout>
Slate's default is `true` since the default block (paragraph) is first-class, while Plate plugins are likely used to define other node behaviors that shouldn't automatically remove empty predecessors.
</Callout>

## `normalizeRules`

Controls how nodes are normalized during the normalization process.

### Configuration

```tsx
LinkPlugin.configure({
  node: {
    normalizeRules: {
      // Whether to remove nodes with empty text
      removeEmpty: boolean,
    },
  },
});
```

### Examples

**Remove empty link nodes:**

```tsx
import { LinkPlugin } from '@udecode/plate-link/react';

const plugins = [
  // ...otherPlugins,
  LinkPlugin.configure({
    node: {
      normalizeRules: { removeEmpty: true },
    },
  }),
];
```

Before normalization:
```tsx
<p>
  <a href="http://google.com">
    <text />
  </a>
  <cursor />
</p>
```

After normalization (empty link removed):
```tsx
<p>
  <cursor />
</p>
```

## `matchRules`

Applies rules conditionally based on node properties beyond just type. This is useful to override the behavior of another plugin.

### Examples

**List plugin matching by `listStyleType`:**

```tsx
import { ListPlugin } from '@udecode/plate-list/react';

const plugins = [
  // ...otherPlugins,
  ListPlugin.configure({
    node: {
      breakRules: { empty: 'reset' },
      deleteRules: { start: 'reset' },
      mergeRules: { removeEmpty: false },
      matchRules: ({ rule, node }) => {
        return Boolean(node.listStyleType);
      },
    },
  }),
];
```

Since the list plugin extends existing blocks that already have their own plugin configuration (e.g. `ParagraphPlugin`), using `matchRules` allows you to override those behaviors.

**Code block matching by emptiness:**

```tsx
import { CodeBlockPlugin } from '@udecode/plate-code-block/react';

const plugins = [
  // ...otherPlugins,
  CodeBlockPlugin.configure({
    node: {
      deleteRules: { empty: 'reset' },
      matchRules: ({ editor, rule }) => {
        return (
          ['break.empty', 'delete.empty'].includes(rule) &&
          isCodeBlockEmpty(editor)
        );
      },
    },
  }),
];
```

Since code blocks have nested code lines, we need custom matching logic to determine when the node is actually empty.

## Custom Reset Logic

Some plugins need special reset behavior beyond the standard paragraph conversion. You can override the `resetBlock` transform:

**List plugin reset (outdents instead of converting to paragraph):**

```tsx
const ListPlugin = createPlatePlugin({
  key: 'list',
  // ... other config
}).overrideEditor(({ editor, tf: { resetBlock } }) => ({
  transforms: {
    resetBlock(options) {
      if (editor.api.block(options)?.[0]?.listStyleType) {
        outdentList();
        return;
      }
      
      return resetBlock(options);
    },
  },
}));
```

**Code block reset (unwraps instead of converting):**

```tsx
const CodeBlockPlugin = createPlatePlugin({
  key: 'code_block',
  // ... other config
}).overrideEditor(({ editor, tf: { resetBlock } }) => ({
  transforms: {
    resetBlock(options) {
      if (editor.api.block({
        at: options?.at,
        match: { type: 'code_block' },
      })) {
        unwrapCodeBlock();
        return;
      }
      
      return resetBlock(options);
    },
  },
}));
```

## Combining Rules

You can combine different rules for comprehensive block behavior:

```tsx
import { BlockquotePlugin } from '@udecode/plate-basic-nodes/react';

const plugins = [
  // ...otherPlugins,
  BlockquotePlugin.configure({
    node: {
      breakRules: {
        default: 'lineBreak',
        empty: 'reset',
        emptyLineEnd: 'deleteExit',
      },
      deleteRules: {
        start: 'reset',
      },
    },
  }),
];
```

**Line break behavior (default):**
```tsx
<blockquote>
  Hello|
</blockquote>
```

After `Enter`:
```tsx
<blockquote>
  Hello
  |
</blockquote>
```

**Empty reset behavior:**
```tsx
<blockquote>
  |
</blockquote>
```

After `Enter`:
```tsx
<p>
  |
</p>
```

**Start reset behavior:**
```tsx
<blockquote>
  |Quote content
</blockquote>
```

After `Backspace`:
```tsx
<p>
  |Quote content
</p>
```

## Advanced

For complex scenarios beyond simple rules, you can override editor transforms directly using [`.overrideEditor`](/docs/plugin-methods#overrideeditor). This gives you complete control over transforms like [`resetBlock`](/docs/plugin-methods#extendtransforms) and [`insertExitBreak`](/docs/plugin-methods#extendtransforms):

```tsx
const CustomPlugin = createPlatePlugin({
  key: 'custom',
  // ... other config
}).overrideEditor(({ editor, tf: { insertBreak, deleteBackward, resetBlock } }) => ({
  transforms: {
    insertBreak() {
      const block = editor.api.block();
      
      if (/* Custom condition */) {
        // Custom behavior
        return;
      }
      
      // Default behavior
      insertBreak();
    },
    
    deleteBackward(unit) {
      const block = editor.api.block();
      
      if (/* Custom condition */) {
        // Custom behavior
        return;
      }
      
      deleteBackward(unit);
    },
    
    resetBlock(options) {
      if (/* Custom condition */) {
        // Custom behavior
        return true;
      }
      
      return resetBlock(options);
    },
  },
}));
```
